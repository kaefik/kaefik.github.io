<!DOCTYPE html>
<html lang="ru">
<head>
        <meta charset="utf-8" />
        <title>PostgreSQL - общая информация</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
<a href="https://github.com/kaefik">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" />
</a>
        <header id="banner" class="body">
                <h1><a href="/">Общественная записная книжка  <strong>следы для себя и потомков</strong></a></h1>
                <nav><ul>
                </ul>
<form id="search" action"#" onsubmit="javascript:window.open('https://duckduckgo.com/?q='+document.getElementById('keywords').value+'+site:');">
                        <input id="keywords" type="text" />
                    </form>
                </nav>
<div id="submenu">
                    <ul>
                            <li><a href="/category/anime.html">anime</a></li>
                            <li><a href="/category/arduino.html">arduino</a></li>
                            <li><a href="/category/bios.html">bios</a></li>
                            <li><a href="/category/blogger.html">blogger</a></li>
                            <li><a href="/category/chromeos.html">chromeos</a></li>
                            <li><a href="/category/clojure.html">clojure</a></li>
                            <li><a href="/category/design.html">design</a></li>
                            <li><a href="/category/docker.html">docker</a></li>
                            <li><a href="/category/game.html">game</a></li>
                            <li><a href="/category/git.html">git</a></li>
                            <li><a href="/category/go.html">go</a></li>
                            <li><a href="/category/hackintosh.html">hackintosh</a></li>
                            <li><a href="/category/internet.html">internet</a></li>
                            <li><a href="/category/javascript.html">javascript</a></li>
                            <li><a href="/category/lego.html">lego</a></li>
                            <li><a href="/category/linux.html">linux</a></li>
                            <li><a href="/category/linux-with-docker.html">linux-with-docker</a></li>
                            <li><a href="/category/lua.html">lua</a></li>
                            <li><a href="/category/machine_learning.html">machine_learning</a></li>
                            <li><a href="/category/main.html">main</a></li>
                            <li><a href="/category/miband.html">miband</a></li>
                            <li><a href="/category/minecraft.html">minecraft</a></li>
                            <li><a href="/category/miui.html">miui</a></li>
                            <li><a href="/category/money.html">money</a></li>
                            <li><a href="/category/mongodb.html">mongodb</a></li>
                            <li><a href="/category/mouse.html">mouse</a></li>
                            <li><a href="/category/network.html">network</a></li>
                            <li><a href="/category/openstreetmap.html">openstreetmap</a></li>
                            <li><a href="/category/os.html">os</a></li>
                            <li><a href="/category/osm.html">osm</a></li>
                            <li><a href="/category/otkrytye-dannye.html">открытые данные</a></li>
                            <li><a href="/category/postgis.html">postgis</a></li>
                            <li class="active"><a href="/category/postgresql.html">PostgreSQL</a></li>
                            <li><a href="/category/powershell.html">powershell</a></li>
                            <li><a href="/category/programming.html">programming</a></li>
                            <li><a href="/category/projects.html">projects</a></li>
                            <li><a href="/category/python.html">python</a></li>
                            <li><a href="/category/radio.html">radio</a></li>
                            <li><a href="/category/rest-api.html">rest-api</a></li>
                            <li><a href="/category/rust.html">rust</a></li>
                            <li><a href="/category/sailfish.html">sailfish</a></li>
                            <li><a href="/category/security.html">security</a></li>
                            <li><a href="/category/selenium.html">selenium</a></li>
                            <li><a href="/category/shell.html">shell</a></li>
                            <li><a href="/category/swift.html">swift</a></li>
                            <li><a href="/category/tatar.html">tatar</a></li>
                            <li><a href="/category/video.html">video</a></li>
                            <li><a href="/category/voice-assistant.html">voice-assistant</a></li>
                            <li><a href="/category/vscode.html">vscode</a></li>
                            <li><a href="/category/wifi.html">wifi</a></li>
                            <li><a href="/category/windows.html">windows</a></li>
                    </ul>
                <div>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2017/09/18/postgresql/" rel="bookmark"
           title="Permalink to PostgreSQL - общая информация">PostgreSQL - общая информация</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>Пн 18 сентября 2017</span>
<span>| tags: <a href="/tag/postgresql.html">PostgreSQL</a><a href="/tag/db.html">db</a><a href="/tag/bazy-dannykh.html">базы данных</a></span>
</footer><!-- /.post-info -->      <h2>Полезные ссылки</h2>
<ul>
<li><a href="http://www.kaefik.ru/2017/09/postgresql_20.html">настройка PostfreSQL</a></li>
<li><a href="https://postgrespro.ru/docs/postgresql/9.6/index.html">Документация к PostgreSQL 9.6.5</a></li>
<li><a href="http://wiki.postgresql.org/wiki/Community_Guide_to_PostgreSQL_GUI_Tools">Community Guide to PostgreSQL GUI Tools</a></li>
<li><a href="http://www.sqltabs.com/">Rich SQL client</a> -  графическая SQL консоль для Postgresql. Это новый GUI клиент, в котором можно просматривать объекты базы данных, писать SQL запросы и строить графики.</li>
<li><a href="http://postgresql.leopard.in.ua/html/">Работа с PostgreSQL: настройка и масштабирование</a></li>
<li><a href="https://www.youtube.com/watch?v=h_GdEaF1Ymc&amp;list=PLaFqU3KCWw6KzGwUubZm-9-vKsi6vh5qC">Администрирование PostgreSQL 9.4. Базовый Курс</a></li>
<li><a href="http://pgcookbook.ru/index.html">Книга рецептов для СУБД PostgreSQL</a></li>
</ul>
<h2>Мои записи</h2>
<ul>
<li><a href="http://www.kaefik.ru/2017/09/postgresql_20.html">PostgreSQL - настройка</a></li>
<li>
<p><a href="http://www.kaefik.ru/2017/09/postgresql-psql.html">PostgreSQL - использование psql</a></p>
</li>
<li>
<p><a href="http://www.kaefik.ru/2017/10/postgresql.html">PostgreSQL - Базы данных</a></p>
</li>
<li><a href="http://www.kaefik.ru/2017/10/postgresql_4.html">PostgreSQL - табличные пространства</a></li>
<li><a href="http://www.kaefik.ru/2017/10/postgresql_20.html">PostgreSQL - системный каталог</a></li>
<li><a href="http://www.kaefik.ru/2017/10/postgresql_7.html">PostgreSQL - Типы данных</a></li>
<li><a href="http://www.kaefik.ru/2017/10/postgresql-sql.html">PostgreSQL - язык SQL</a></li>
<li><a href="http://www.kaefik.ru/2017/10/postgresql-sql_7.html">PostgreSQL - язык SQL (расширенные возможности)</a></li>
</ul>
<h2>Настройка</h2>
<ul>
<li>
<p><strong>Общий буфер сервера: shared_buffers</strong> - На выделенных серверах полезным объемом для shared_buffers будет значение 1/4 памяти в системе. Если у вас большие активные порции базы данных, сложные запросы, большое число одновременных соединений, длительные транзакции, вам доступен большой объем оперативной памяти или большее количество процессоров, то можно подымать это значение и мониторить результат, чтобы не привести к «деградации» (падению) производительности. Выделив слишком много памяти для базы данных, мы можем получить ухудшение производительности, поскольку PostgreSQL также использует кэш операционной системы (увеличение данного параметра более 40% оперативной памяти может давать «нулевой» прирост производительности).  Проверяйте использование разделяемой памяти при помощи ipcs или других утилит(например, free или vmstat). Рекомендуемое значение параметра будет примерно в 1,2 –2 раза больше, чем максимум использованной памяти</p>
</li>
<li>
<p><strong>Память для сортировки результата запроса: work_mem</strong> - work_mem параметр определяет максимальное количество оперативной памяти, которое может выделить одна операция сортировки, агрегации и др. Это не разделяемая память, work_mem выделяется отдельно на каждую операцию (от одного до нескольких раз за один запрос). Разумное значение параметра определяется следующим образом: количество доступной оперативной памяти (после того, как из общего объема вычли память, требуемую для других приложений, и shared_buffers) делится на максимальное число одновременных запросов умноженное на среднее число операций в запросе, которые требуют памяти.</p>
</li>
<li>
<p><strong>Максимальное количество клиентов: max_connections</strong> - Параметр max_connections устанавливает максимальное количество клиентов, которые могут подключиться к PostgreSQL. Поскольку для каждого клиента требуется выделять память (work_mem), то этот параметр предполагает максимально возможное использование памяти для всех клиентов</p>
</li>
<li>
<p><strong>Память для работы команды VACUUM: maintenance_work_mem</strong> - Этот параметр задаёт объём памяти, используемый командами VACUUM, ANALYZE, CREATE INDEX, и добавления внешних ключей. Чтобы операции выполнялись максимально быстро, нужно устанавливать этот параметр тем выше, чем больше размер таблиц в вашей базе данных. Неплохо бы устанавливать его значение от 50 до 75% размера вашей самой большой таблицы или индекса или, если точно определить невозможно, от 32 до 256 МБ.</p>
</li>
<li>
<p><strong>temp_buffers</strong> — буфер под временные объекты, в основном для временных таблиц. Можно установить порядка 16 МБ;</p>
</li>
<li>
<p><strong>max_prepared_transactions</strong> — количество одновременно подготавливаемых транзакций (PREPARE TRANSACTION). Можно оставить по умолчанию — 5;</p>
</li>
<li>
<p><strong>vacuum_cost_delay</strong> — если у вас большие таблицы, и производится много одновременных операций записи, вам может пригодиться функция, которая уменьшает затраты на I/O для VACUUM, растягивая его по времени. Чтобы включить эту функциональность, нужно поднять значение vacuum_cost_delay выше 0. Используйте разумную задержку от 50 до 200 мс. Для более тонкой настройки повышайте vacuum_cost_page_hit и понижайте vacuum_cost_page_limit. Это ослабит влияние VACUUM, увеличив время его выполнения. В тестах с параллельными транзакциями Ян Вик (Jan Wieck) получил, что при значениях delay — 200, page_hit — 6 и limit —100 влияние VACUUM уменьшилось более чем на 80%, но его длительность увеличилась втрое;</p>
</li>
<li><strong>max_stack_depth</strong> — cпециальный стек для сервера, который в идеале должен совпадать с размером стека, выставленном в ядре ОС. Установка большего значения, чем в ядре, может привести к ошибкам. Рекомендуется устанавливать 2–4 MB;</li>
<li><strong>max_files_per_process</strong> — максимальное количество файлов, открываемых процессом и его подпроцессами в один момент времени. Уменьшите данный параметр, если в процессе работы наблюдается сообщение «Too many open files»;</li>
</ul>
<h2>Перенос журнала транзакций на отдельный диск</h2>
<p>При доступе к диску изрядное время занимает не только собственно чтение данных, но и перемещение магнитной головки.Если в вашем сервере есть несколько физических дисков (несколько логических разделов на одном диске здесь, очевидно, не помогут: головка всё равно будет одна), то вы можете разнести файлы базы данных и журнал транзакций по разным дискам. Данные в сегменты журнала пишутся последовательно, более того, записи в журнале транзакций сразу сбрасываются на диск, поэтому в случае нахождения его на отдельном диске магнитная головка не будет лишний раз двигаться, что позволит ускорить запись.</p>
<p>Порядок действий:</p>
<ul>
<li>Остановите сервер (!); </li>
<li>Перенесите каталоги pg_clog и pg_xlog, находящийся в каталоге с базами данных, на другой диск;</li>
<li>Создайте на старом месте символическую ссылку;</li>
<li>Запустите сервер;</li>
</ul>
<h2>Индексы</h2>
<h3>Типы индексов:</h3>
<ul>
<li><strong>B-Tree</strong> - называют упорядоченное блочное дерево. Узлы в дереве представляют из себя блоки фиксированного размера. У каждого узла фиксированное число детей. В индексном B-Tree значения и RowId размещаются совместно на нижнем слое дерева. Каждый узел дерева представляет из себя одну страницу (page) в некотором формате.</li>
<li><strong>R-Tree</strong> (Rectangle-Tree) предназначен для хранения пар (X, Y) значений числового типа (например, координат). По способу организации R-Tree очень похоже на B-Tree. Единственное отличие — это информация, записываемая в промежуточные страницы в дереве. Для i-го значения в узле в B-Tree мы пишем максимум из i-го поддерева, а в R-Tree — минимальный прямоугольник, покрывающий все прямоугольники из ребёнка</li>
<li><strong>Hash индекс</strong> по сути является ассоциативным хеш-контейнером. Хеш-контейнер — это массив из разряженных значений. Адресуются отдельные элементы этого массива некоторой хеш-функцией которая отображает каждое значение в некоторое целое число. Т.е. результат хеш-функции является порядковым номером элемента в массиве. Элементы массива в хеш-конейтнере называются букетами (bucket). Обычно один букет — одна странца. Хеш-функция отображает более мощное множество в менее мощное, возникают так называемые коллизии — ситуация, когда одному значению хеш-функции соответствует несколько разных значений. В букете хранятся значения, образующие коллизию. Разрешение коллизий происходит посредством поиска среди значений, сохранённых в букете.</li>
<li><strong>Битовый индекс (bitmap index)</strong> — метод битовых индексов заключается в создании отдельных битовых карт (последовательность 0 и 1) для каждого возможного значения столбца, где каждому биту соответствует строка с индексируемым значением, а его значение равное 1 означает, что запись, соответствующая позиции бита содержит индексируемое значение для данного столбца или свойства (алгоритм Хаффмана).</li>
<li><strong>GiST (Generalized Search Tree)</strong> — обобщение B-Tree, R-Tree дерево поиска по произвольному предикату. Структура дерева не меняется, по-прежнему в каждом нелистовом узле хранятся пары (Значения, Номер страницы), а количество детей совпадает с количеством пар в узле. Существенное отличие состоит в организации ключа. B-Tree деревья заточены под поиск диапазонов и хранят максимумы поддерева-ребёнка. R-Tree — региона на координатной плоскости. GiST предлагает в качестве значений в нелистовых узлах хранить ту информацию, которую мы считаем существенной, и которая позволит определить, есть ли интересующие нас значения (удовлетворяющие предикату) в поддереве-ребёнке. Конкретный вид хранимой информации зависит от вида поиска, который мы желаем проводить. Таким образом параметризовав R-Tree и B-Tree дерево предикатами и значениями мы автоматически получаем специализированный под задачу индекс (PostGiST, pg_trgm, hstore, ltree, прочее).</li>
<li><strong>GIN (Generalized Inverted Index)</strong> — обратный индекс, используемым полнотекстовым поиском PostgreSQL. Это означает, что в структуре индексов с каждой лексемой сопоставляется отсортированный список номеров документов, в которых она встречается. Очевидно, что поиск по такой структуре намного эффективнее, чем при использовании GiST, однако процесс добавления нового документа достаточно длителен.</li>
<li><strong>Cluster индекс</strong> - Не является индексом, поскольку производит кластеризацию таблицы по заданному индексу. Более подробно можно почитать в разделе «[sec:hard-drive-cluster] »</li>
<li><strong>BRIN индекс</strong> - в отличие от привычного B-Tree, этот индекс намного эффективнее для очень больших таблиц, и в некоторых ситуациях позволяет заменить собой партицирование (подробно можно почитать в разделе «[sec:partitioning] »). BRIN-индекс имеет смысл применять для таблиц, в которых часть данных уже по своей природе как-то отсортирована. Например, это характерно для логов или для истории заказов магазина, которые пишутся последовательно, а потому уже на физическом уровне упорядочены по дате/номеру, и в то же время таблицы с такими данными обычно разрастаются до гигантских размеров.</li>
</ul>
<h2>Возможности индексов</h2>
<ul>
<li><strong>Функциональный индекс (functional index)</strong> - можете построить индекс не только по полю/нескольким полям таблицы, но и по выражению, зависящему от полей. Пусть, например, в вашей таблице foo есть поле foo_name, и выборки часто делаются по условию «первая буква из поля foo_name в любом регистре». Вы можете создать индекс </li>
</ul>
<p><code>sql
  CREATE INDEX foo_name_first_idx ON foo ((lower(substr(foo_name, 1, 1))));</code></p>
<p>и запрос вида</p>
<p><code>sql
  SELECT * FROM foo WHERE lower(substr(foo_name, 1, 1)) = 'а';</code></p>
<p>будет его использовать.</p>
<ul>
<li>
<p><strong>Частичный индекс (partial index)</strong> - под частичным индексом понимается индекс с предикатом WHERE. Пусть, например, у вас есть в базе таблица scheta с параметром uplocheno типа boolean. Записей, где uplocheno = false меньше, чем записей с  uplocheno = true, а запросы по ним выполняются значительно чаще. Вы можете создать индексCREATE INDEX scheta_neuplocheno ON scheta (id) WHERE NOT uplocheno;который будет использоваться запросом видаSELECT * FROM scheta WHERE NOT uplocheno AND ...;Достоинство подхода в том, что записи, не удовлетворяющие условию WHERE, просто не попадут в индекс.</p>
</li>
<li>
<p>Уникальный индекс (unique index) - уникальный индекс гарантирует, что таблица не будет иметь более чем одну строку с тем же значением. Это удобно по двум причинам: целостность данных и производительность. Поиск данных с использованием уникального индекса, как правило, очень быстрый.</p>
</li>
<li>
<p>Индекс нескольких столбцов (multi-column index)</p>
</li>
</ul>
<h2>Расширения</h2>
<ul>
<li><strong>PostPic</strong> - расширение для PostgreSQL, которое позволяет обрабатывать изображения в базе данных, как PostGIS делает это с пространственными данными. Он добавляет новый типа поля image, а также несколько функций для обработки изображений (обрезка краев, создание миниатюр, поворот и т.д.) и извлечений его атрибутов (размер, тип, разрешение). Более подробно о возможностях расширения можно ознакомиться на официальной странице.</li>
</ul>
<h2>Бэкап и восстановление PostgreSQL</h2>
<p>Существуют три принципиально различных подхода к резервному копированию данных PostgreSQL:</p>
<ul>
<li>SQL бэкап;                   </li>
<li>Бэкап уровня файловой системы;</li>
<li>Непрерывное резервное копирование;</li>
</ul>
<h2>SQL бэкап</h2>
<p>Идея этого подхода в создании текстового файла с командами SQL. Такой файл можно передать обратно на сервер и воссоздать базу данных в том же состоянии, в котором она была во время бэкапа. У PostgreSQL для этого есть специальная утилита — pg_dump. Пример использования pg_dump:</p>
<div class="highlight"><pre><span></span><span class="n">pg_dump</span> <span class="n">dbname</span> <span class="o">&gt;</span> <span class="n">outfile</span>
</pre></div>


<p>Для восстановления такого бэкапа достаточно выполнить:</p>
<div class="highlight"><pre><span></span><span class="n">psql</span> <span class="n">dbname</span> <span class="o">&lt;</span> <span class="n">infile</span>
</pre></div>


<p>При этом базу данных dbname потребуется создать перед восстановлением. Также потребуется создать пользователей, которые имеют доступ к данным, которые восстанавливаются (это можно и не делать, но тогда просто в выводе восстановления будут ошибки). Если нам требуется, чтобы восстановление прекратилось при возникновении ошибки, тогда потребуется восстанавливать бэкап таким способом:</p>
<div class="highlight"><pre><span></span>psql --set ON_ERROR_STOP=on dbname &lt; infile
</pre></div>


<p>Также, можно делать бэкап и сразу восстанавливать его в другую базу:</p>
<div class="highlight"><pre><span></span>pg_dump -h host1 dbname | psql -h host2 dbname
</pre></div>


<p>После восстановления бэкапа желательно запустить ANALYZE, чтобы оптимизатор запросов обновил статистику.</p>
<p>А что, если нужно сделать бэкап не одной базы данных, а всех, да и еще получить в бэкапе информацию про роли и таблицы? В таком случае у PostgreSQL есть утилита pg_dumpall. pg_dumpall используется для создания бэкапа данных всего кластера PostgreSQL:</p>
<div class="highlight"><pre><span></span>pg_dumpall &gt; outfile
</pre></div>


<p>Для восстановления такого бэкапа достаточно выполнить от суперпользователя:</p>
<div class="highlight"><pre><span></span>psql -f infile postgres
</pre></div>


<h2>SQL бекап больших баз данных</h2>
<p>Некоторые операционные системы имеют ограничения на максимальный размер файла, что может вызывать проблемы при создании больших бэкапов через pg_dump. К счастью, pg_dump можете бэкапить в стандартный вывод. Так что можно использовать стандартные инструменты Unix, чтобы обойти эту проблему. Есть несколько возможных способов:</p>
<h3>Использовать сжатие для бэкапа</h3>
<p>Можно использовать программу сжатия данных, например GZIP:</p>
<div class="highlight"><pre><span></span>pg_dump dbname | gzip &gt; filename.gz
</pre></div>


<ul>
<li>Восстановление:</li>
</ul>
<div class="highlight"><pre><span></span>gunzip -c filename.gz | psql dbname
</pre></div>


<p>или</p>
<div class="highlight"><pre><span></span>cat filename.gz | gunzip | psql dbname
</pre></div>


<ul>
<li>Использовать команду split
  Команда split позволяет разделить вывод в файлы меньшего размера, которые являются подходящими по размеру для файловой системы. Например, бэкап делится на куски по 1 мегабайту:</li>
</ul>
<p><code>pg_dump dbname | split -b 1m - filename</code></p>
<h3>Восстановление:</h3>
<div class="highlight"><pre><span></span>cat filename* | psql dbname
</pre></div>


<p>Использовать пользовательский формат дампа pg_dump
PostgreSQL построен на системе с библиотекой сжатия Zlib, поэтому пользовательский формат бэкапа будет в сжатом виде. Это похоже на метод с использованием GZIP, но он имеет дополнительное преимущество — таблицы могут быть восстановлены выборочно. Минус такого бэкапа — восстановить возможно только в такую же версию PostgreSQL (отличаться может только патч релиз, третья цифра после точки в версии):</p>
<div class="highlight"><pre><span></span>pg_dump -Fc dbname &gt; filename
</pre></div>


<p>Через psql такой бэкап не восстановить, но для этого есть утилита pg_restore:</p>
<div class="highlight"><pre><span></span> pg_restore -d dbname filename
</pre></div>


<p>При слишком большой базе данных, вариант с командой split нужно комбинировать со сжатием данных.</p>
<h2>Непрерывное резервное копирование</h2>
<p>PostgreSQL поддерживает упреждающую запись логов (Write Ahead Log, WAL) в pg_xlog директорию, которая находится в директории данных СУБД. В логи пишутся все изменения, сделанные с данными в СУБД. Этот журнал существует прежде всего для безопасности во время краха PostgreSQL: если происходят сбои в системе, базы данных могут быть восстановлены с помощью «перезапуска» этого журнала. Тем не менее, существование журнала делает возможным использование третьей стратегии для резервного копирования баз данных: мы можем объединить бэкап уровня файловой системы с резервной копией WAL файлов. Если требуется восстановить такой бэкап, то мы восстанавливаем файлы резервной копии файловой системы, а затем «перезапускаем» с резервной копии файлов WAL для приведения системы к актуальному состоянию. Этот подход является более сложным для администрирования, чем любой из предыдущих подходов, но он имеет некоторые преимущества:Не нужно согласовывать файлы резервной копии системы. Любая внутренняя противоречивость в резервной копии будет исправлена путем преобразования журнала (не отличается от того, что происходит во время восстановления после сбоя);Восстановление состояния сервера для определенного момента времени;Если мы постоянно будем «скармливать» файлы WAL на другую машину, которая была загружена с тех же файлов резервной базы, то у нас будет находящийся всегда в актуальном состоянии резервный сервер PostgreSQL (создание сервера горячего резерва);Как и бэкап файловой системы, этот метод может поддерживать только восстановление всей базы данных кластера. Кроме того, он требует много места для хранения WAL файлов.**</p>
<h3>Настройка</h3>
<ul>
<li>Первый шаг — активировать архивирование. Эта процедура будет копировать WAL файлы в архивный каталог из стандартного каталога pg_xlog. Это делается в файле postgresql.conf:</li>
</ul>
<p><code>archive_mode = on # enable archiving
  archive_command = 'cp -v %p /data/pgsql/archives/%f'
  archive_timeout = 300 # timeout to close buffers</code></p>
<ul>
<li>После этого необходимо перенести файлы (в порядке их появления) в архивный каталог. Для этого можно использовать функцию rsync. Можно поставить функцию в cron и, таким образом, файлы могут автоматически перемещаться между хостами каждые несколько минут:</li>
</ul>
<p><code>bash
  rsync -avz --delete prod1:/data/pgsql/archives/ \
  /data/pgsql/archives/ &gt; /dev/null</code></p>
<ul>
<li>В конце необходимо скопировать файлы в каталог pg_xlog на сервере PostgreSQL (он должен быть в режиме восстановления). Для этого необходимо в каталоге данных PostgreSQL создать файл recovery.conf с заданной командой копирования файлов из архива в нужную директорию:</li>
</ul>
<p><code>restore_command = 'cp /data/pgsql/archives/%f "%p"'</code></p>
<p>Документация PostgreSQL предлагает хорошее описание настройки непрерывного копирования, поэтому данная глава не будет углубляться в детали (например, как перенести директорию СУБД с одного сервера на другой, какие могут быть проблемы). Более подробно вы можете почитать по этой ссылке.</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="https://twitter.com/oILnur">Twitter</a></li>
                            <li><a href="mailto: ilnursoft@gmail.com">Email</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, inspired by the default theme.</p>
        </footer><!-- /#contentinfo -->

</body>
</html>